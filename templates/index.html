<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="author" content="Andres Masanelli" />
    <meta name="robots" content="index, follow" />
    <meta name="keywords" content="billion, checkboxes" />

    <meta name="description" property="og:description" content="One billion checkboxes to be checked!" />
    <meta name="type" property="og:type" content="website" />
    <meta name="image" property="og:image" content="social.png" />
    <meta name="url" property="og:url" content="billionchecks.com" />
    <meta name="title" property="og:title" content="One Billion Checkboxes" />

    <link rel="icon" href="favicon.png" type="image/png" />
    <title>One Billion Checkboxes</title>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-CNV93KL3Z8"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());
      gtag("config", "G-CNV93KL3Z8");
    </script>

    <style>
      * {
        font-family: Arial, sans-serif;
        font-size: 16px;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        text-align: center;
        color: #333;
      }

      body {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      #header {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 10px;
        justify-content: space-around;
        min-height: 100px;
        border-bottom: 1px solid #333;
        padding: 10px;
      }

      h1 {
        font-size: 2em;
      }

      #search {
        width: 100px;
      }

      #scrollable {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow-y: scroll;
        overflow-x: auto;
      }

      .loading {
        padding: 5px;
        height: 30px;
      }

      .loading.hidden {
        display: none;
      }

      .spinner {
        margin: auto;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(0, 0, 0, 0.1);
        border-top-color: #333;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .row {
        text-wrap: nowrap;
        height: 30px;
      }

      input[type="checkbox"] {
        width: 20px;
        height: 20px;
        margin: 5px;
      }

      input[type="checkbox"].waiting {
        opacity: 0.5;
        cursor: wait;
      }

      #footer {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        padding: 10px;
        border-top: 1px solid #333;
      }

      .icon {
        vertical-align: text-bottom;
        width: 1em;
        height: 1em;
      }

      .button {
        display: inline-block;
        padding: 5px 10px;
        background-color: #ffdd00;
        text-decoration: none;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <div id="header">
      <div><span id="counter">0</span> checks</div>
      <h1>One Billion Checkboxes</h1>
      <input id="search" type="number" placeholder="search" />
    </div>

    <div id="scrollable">
      <div id="loading-up" class="loading hidden">
        <div class="spinner"></div>
      </div>
      <div id="rows-container"></div>
      <div id="loading-down" class="loading">
        <div class="spinner"></div>
      </div>
    </div>

    <div id="footer">
      <div>
        <!-- prettier-ignore -->
        <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#333" d="m12.89 3l1.96.4L11.11 21l-1.96-.4zm6.7 9L16 8.41V5.58L22.42 12L16 18.41v-2.83zM1.58 12L8 5.58v2.83L4.41 12L8 15.58v2.83z"/></svg>
        with
        <!-- prettier-ignore -->
        <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#333" d="m12 21.35l-1.45-1.32C5.4 15.36 2 12.27 2 8.5C2 5.41 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.08C13.09 3.81 14.76 3 16.5 3C19.58 3 22 5.41 22 8.5c0 3.77-3.4 6.86-8.55 11.53z"/></svg>
        by <a href="{{.MeURL}}" target="_blank">me</a>, drawing inspiration from <a href="https://onemillioncheckboxes.com">eieio</a>.
      </div>
      <div>
        <a class="button" href="{{.BuyMeACoffeeURL}}" target="_blank">
          Buy me a
          <!-- prettier-ignore -->
          <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#333" d="M18.5 3H6c-1.1 0-2 .9-2 2v5.71c0 3.83 2.95 7.18 6.78 7.29c3.96.12 7.22-3.06 7.22-7v-1h.5c1.93 0 3.5-1.57 3.5-3.5S20.43 3 18.5 3M16 5v3H6V5zm2.5 3H18V5h.5c.83 0 1.5.67 1.5 1.5S19.33 8 18.5 8M4 19h16v2H4z"/></svg>
        </a>
      </div>
    </div>

    <script>
      const totalCheckboxes = parseInt("{{.TotalCheckboxes}}");
      const reconnectInterval = parseInt("{{.ReconnectInterval}}");
      const checkboxSize = 30;
      const extraRowsToRender = 10;

      let websocket;
      const scrollable = document.getElementById("scrollable");
      const rowsContainer = document.getElementById("rows-container");
      const loadingUp = document.getElementById("loading-up");
      const loadingDown = document.getElementById("loading-down");
      const search = document.getElementById("search");

      const rowsPerScreen = Math.floor(scrollable.clientHeight / checkboxSize);
      const checkboxesPerRow = Math.floor(rowsContainer.clientWidth / checkboxSize);
      const bottomRow = Math.ceil(totalCheckboxes / checkboxesPerRow);
      const firstRowOfBottomScreen = bottomRow - (rowsPerScreen - 1);

      const rowObserver = new IntersectionObserver(
        (entries) => {
          for (const entry of entries) {
            if (entry.isIntersecting) {
              entry.target.viewed = true; // allows to add rows outside the viewport
            } else if (entry.target.viewed) {
              const row = document.getElementById(entry.target.id);
              if (!row) {
                return;
              }

              entry.target.remove(); // the row must be marked as viewed before removing

              const firstRow = rowsContainer.firstElementChild;
              const firstCheckbox = firstRow.firstElementChild;
              const firstId = parseInt(firstCheckbox.id.slice(1));

              if (firstId > 1) {
                loadingUp.classList.remove("hidden");
              } else {
                loadingUp.classList.add("hidden");
              }

              const lastRow = rowsContainer.lastElementChild;
              const lastCheckbox = lastRow.lastElementChild;
              const lastId = parseInt(lastCheckbox.id.slice(1));

              if (lastId < totalCheckboxes) {
                loadingDown.classList.remove("hidden");
              } else {
                loadingDown.classList.add("hidden");
              }
            }
          }
        },
        {
          root: scrollable,
          rootMargin: `${extraRowsToRender * checkboxSize * 2}px`,
        }
      );

      const upObserver = new IntersectionObserver(
        (entries) => {
          if (entries[0].isIntersecting) {
            const firstRow = rowsContainer.firstElementChild;
            const firstRowId = parseInt(firstRow.id.slice(1));
            const firstCheckbox = firstRow.firstElementChild;
            const firstId = parseInt(firstCheckbox.id.slice(1));

            const rowsToRender = Math.min(firstId / checkboxesPerRow, extraRowsToRender);

            if (rowsToRender === 0) {
              loadingUp.classList.add("hidden");
              return;
            }

            let id = firstId - 1;
            for (let y = 1; y <= rowsToRender; y++) {
              const div = document.createElement("div");
              div.classList.add("row");
              div.id = `r${firstRowId - y}`;

              for (let x = 1; x <= checkboxesPerRow; x++) {
                const input = newCheckbox(id);
                div.prepend(input);
                id--;
              }

              rowsContainer.prepend(div);
              rowObserver.observe(div);
            }

            getData(id + 1, firstId - 1);

            scrollable.scrollTop = extraRowsToRender * checkboxSize;
          }
        },
        {
          root: scrollable,
          threshold: 0.5,
        }
      );

      const downObserver = new IntersectionObserver(
        (entries) => {
          if (entries[0].isIntersecting) {
            const lastRow = rowsContainer.lastElementChild;
            const lastRowId = parseInt(lastRow.id.slice(1));
            const lastCheckbox = lastRow.lastElementChild;
            const lastId = parseInt(lastCheckbox.id.slice(1));

            const rowsToRender = Math.min(Math.ceil((totalCheckboxes - lastId) / checkboxesPerRow), extraRowsToRender);

            if (rowsToRender === 0) {
              loadingDown.classList.add("hidden");
              return;
            }

            let id = lastId + 1;
            for (let y = 1; y <= rowsToRender; y++) {
              const div = document.createElement("div");
              div.classList.add("row");
              div.id = `r${y + lastRowId}`;

              const checkboxes = Math.min(totalCheckboxes - (id - 1), checkboxesPerRow);

              for (let x = 1; x <= checkboxes; x++) {
                const input = newCheckbox(id);
                div.append(input);
                id++;
              }

              rowsContainer.append(div);
              rowObserver.observe(div);
            }

            getData(lastId + 1, id - 1);
          }
        },
        {
          root: scrollable,
          threshold: 0.5,
        }
      );

      function processData(arrayBuffer) {
        const view = new DataView(arrayBuffer);

        if (view.byteLength === 4) {
          const checks = view.getUint32(0, true);

          const counter = document.getElementById("counter");
          counter.innerHTML = checks;
        } else if (view.byteLength === 8) {
          const checks = view.getUint32(0, true);

          const counter = document.getElementById("counter");
          counter.innerHTML = checks;

          const id = view.getUint32(4, true);

          const checkbox = document.getElementById(`c${id}`);

          if (!checkbox) {
            return;
          }

          checkbox.checked = true;
          checkbox.classList.remove("waiting");
        } else {
          // view.byteLength > 8
          const firstId = view.getUint32(0, true);

          const uint8ArrayLength = arrayBuffer.byteLength - 4;
          const uint8Array = new Uint8Array(arrayBuffer, 4, uint8ArrayLength);

          let id = firstId;
          for (const byte of uint8Array) {
            for (let y = 0; y < 8; y++) {
              const checkbox = document.getElementById(`c${id}`);

              if (!checkbox) {
                continue;
              }

              const checked = (byte >> y) & 1;
              if (checked) {
                checkbox.checked = true;
              } else {
                checkbox.enabled = true;
              }

              checkbox.classList.remove("waiting");

              id++;
            }
          }
        }
      }

      function postData(id) {
        const message = new Uint32Array(1);
        message[0] = id;

        try {
          websocket.send(message);
        } catch (error) {}
      }

      function getData(first, last) {
        const message = new Uint32Array(2);
        message[0] = first;
        message[1] = last;

        try {
          websocket.send(message);
        } catch (error) {}
      }

      function onKeyDown(event) {
        if (event.key !== "Enter") {
          return;
        }

        const idToSearch = this.value;

        if (idToSearch < 1 || idToSearch > totalCheckboxes) {
          return;
        }

        const firstRow = rowsContainer.firstElementChild;
        const firstCheckbox = firstRow.firstElementChild;
        const firstId = parseInt(firstCheckbox.id.slice(1));

        const lastRow = rowsContainer.lastElementChild;
        const lastCheckbox = lastRow.lastElementChild;
        const lastId = parseInt(lastCheckbox.id.slice(1));

        if (idToSearch > lastId || idToSearch < firstId) {
          rowObserver.disconnect();
          upObserver.disconnect();
          downObserver.disconnect();
          loadingUp.classList.add("hidden");
          loadingDown.classList.add("hidden");
          rowsContainer.innerHTML = "";

          const topScreenRowId = Math.min(Math.ceil(idToSearch / checkboxesPerRow), firstRowOfBottomScreen);

          const preExtraRows = Math.min(topScreenRowId - 1, extraRowsToRender);
          const posExtraRows = Math.min(bottomRow - (topScreenRowId - 1) - rowsPerScreen, extraRowsToRender);
          const rowsToRender = preExtraRows + rowsPerScreen + posExtraRows;

          const lastRowId = topScreenRowId - 1 - preExtraRows;
          const lastId = lastRowId * checkboxesPerRow;

          let id = lastId + 1;
          for (let y = 1; y <= rowsToRender; y++) {
            const div = document.createElement("div");
            div.classList.add("row");
            div.id = `r${y + lastRowId}`;

            const checkboxes = Math.min(totalCheckboxes - (id - 1), checkboxesPerRow);

            for (let x = 1; x <= checkboxes; x++) {
              const input = newCheckbox(id);
              div.append(input);
              id++;
            }

            rowsContainer.append(div);
            rowObserver.observe(div);
          }

          getData(lastId + 1, id - 1);
        }

        const checkbox = document.getElementById(`c${idToSearch}`);

        if (!checkbox) {
          return;
        }

        checkbox.focus();

        let scrollTimeout;
        function onScroll() {
          clearTimeout(scrollTimeout);

          scrollTimeout = setTimeout(() => {
            const firstRow = rowsContainer.firstElementChild;
            const firstCheckbox = firstRow.firstElementChild;
            const firstId = parseInt(firstCheckbox.id.slice(1));

            if (firstId > 1) {
              loadingUp.classList.remove("hidden");
            }

            const lastRow = rowsContainer.lastElementChild;
            const lastCheckbox = lastRow.lastElementChild;
            const lastId = parseInt(lastCheckbox.id.slice(1));

            if (lastId < totalCheckboxes) {
              loadingDown.classList.remove("hidden");
            }

            downObserver.observe(loadingDown);
            upObserver.observe(loadingUp);

            scrollable.removeEventListener("scroll", onScroll);
          }, 100);
        }
        scrollable.addEventListener("scroll", onScroll);

        const rowId = Math.ceil(idToSearch / checkboxesPerRow);
        const rowToScrollIntoView = document.getElementById(`r${rowId}`);
        rowToScrollIntoView.scrollIntoView({ behavior: "smooth", block: "start" });
      }

      function newCheckbox(id) {
        const input = document.createElement("input");

        input.type = "checkbox";
        input.id = `c${id}`;
        input.title = id;
        input.enabled = false;
        input.classList.add("waiting");

        input.addEventListener("keydown", (event) => {
          if (!event.target.enabled) {
            event.preventDefault();
          }
        });

        input.addEventListener("click", (event) => {
          if (!event.target.enabled) {
            event.preventDefault();
          }
        });

        input.addEventListener("change", (event) => {
          if (event.target.checked) {
            event.target.enabled = false;
            event.target.classList.add("waiting");
            postData(parseInt(event.target.id.slice(1)));
          }
        });

        return input;
      }

      function init() {
        let id = 1;
        for (let y = 1; y <= rowsPerScreen + extraRowsToRender; y++) {
          const div = document.createElement("div");
          div.classList.add("row");
          div.id = `r${y}`;

          for (let x = 1; x <= checkboxesPerRow; x++) {
            const input = newCheckbox(id);
            div.append(input);
            id++;
          }

          rowsContainer.append(div);
          rowObserver.observe(div);
        }

        getData(1, (rowsPerScreen + extraRowsToRender) * checkboxesPerRow);

        upObserver.observe(loadingUp);
        downObserver.observe(loadingDown);
        search.addEventListener("keydown", onKeyDown);
      }

      function connect() {
        websocket = new WebSocket("{{.WebsocketURL}}");
        websocket.binaryType = "arraybuffer";

        websocket.onopen = function () {
          init();
        };

        websocket.onmessage = function (event) {
          processData(event.data);
        };

        websocket.onclose = function (event) {
          rowObserver.disconnect();
          upObserver.disconnect();
          downObserver.disconnect();
          loadingUp.classList.add("hidden");
          loadingDown.classList.remove("hidden");
          rowsContainer.innerHTML = "";
          search.removeEventListener("keydown", onKeyDown);

          setTimeout(connect, reconnectInterval);
        };

        websocket.onerror = function () {
          websocket.close();
        };
      }

      connect();
    </script>
  </body>
</html>
