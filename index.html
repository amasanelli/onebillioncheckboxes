<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="favicon.png" type="image/png" />
    <title>1.000.000.000 checkboxes</title>
    <style>
      * {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        text-align: center;
        color: #333;
      }

      body {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      #header {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 10px;
        justify-content: space-around;
        min-height: 100px;
        border-bottom: 1px solid #333;
        padding: 10px;
      }

      #search {
        width: 100px;
      }

      #scrollable {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow-y: scroll;
        overflow-x: auto;
      }

      .loading {
        padding: 5px;
        height: 30px;
        width: 100%;
      }

      .loading.hidden {
        display: none;
      }

      .spinner {
        margin: auto;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(0, 0, 0, 0.1);
        border-top-color: #333;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .row {
        text-wrap: nowrap;
        height: 30px;
      }

      input[type="checkbox"] {
        width: 20px;
        height: 20px;
        margin: 5px;
      }

      #footer {
        padding: 10px;
        border-top: 1px solid #333;
      }

      .icon {
        vertical-align: text-bottom;
        width: 1em;
        height: 1em;
      }
    </style>
  </head>
  <body>
    <div id="header">
      <div>x checked</div>
      <h1>One Billion Checkboxes</h1>
      <input id="search" type="number" placeholder="search" />
    </div>

    <div id="scrollable">
      <div id="loading-up" class="loading hidden">
        <div class="spinner"></div>
      </div>
      <div id="rows-container"></div>
      <div id="loading-down" class="loading">
        <div class="spinner"></div>
      </div>
    </div>

    <div id="footer">
      <!-- prettier-ignore -->
      <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#333" d="m12.89 3l1.96.4L11.11 21l-1.96-.4zm6.7 9L16 8.41V5.58L22.42 12L16 18.41v-2.83zM1.58 12L8 5.58v2.83L4.41 12L8 15.58v2.83z"/></svg>
      with
      <!-- prettier-ignore -->
      <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#333" d="m12 21.35l-1.45-1.32C5.4 15.36 2 12.27 2 8.5C2 5.41 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.08C13.09 3.81 14.76 3 16.5 3C19.58 3 22 5.41 22 8.5c0 3.77-3.4 6.86-8.55 11.53z"/></svg>
      by <a href="mailto:me@me.com">me</a> using Go, Redis, Javascript, HTML and CSS.
    </div>

    <script>
      function main() {
        const totalCheckboxes = 10000;
        const checkboxSize = 30;
        const extraRowsToRender = 10;

        const rowsContainer = document.getElementById("rows-container");
        const scrollable = document.getElementById("scrollable");
        const loadingUp = document.getElementById("loading-up");
        const loadingDown = document.getElementById("loading-down");

        const rowsPerScreen = Math.floor(scrollable.clientHeight / checkboxSize);
        const checkboxesPerRow = Math.floor(rowsContainer.clientWidth / checkboxSize);
        const bottomRow = Math.ceil(totalCheckboxes / checkboxesPerRow);
        const firstRowOfBottomScreen = bottomRow - (rowsPerScreen - 1);

        const rowObserver = new IntersectionObserver(
          (entries) => {
            for (const entry of entries) {
              if (entry.isIntersecting) {
                entry.target.viewed = true; // allows to add rows outside the viewport
              } else if (entry.target.viewed) {
                entry.target.remove(); // the row must be marked as viewed before removing

                const firstRow = rowsContainer.firstElementChild;
                const firstCheckbox = firstRow.firstElementChild;
                const firstId = parseInt(firstCheckbox.id.slice(1));

                if (firstId > 1) {
                  loadingUp.classList.remove("hidden");
                } else {
                  loadingUp.classList.add("hidden");
                }

                const lastRow = rowsContainer.lastElementChild;
                const lastCheckbox = lastRow.lastElementChild;
                const lastId = parseInt(lastCheckbox.id.slice(1));

                if (lastId < totalCheckboxes) {
                  loadingDown.classList.remove("hidden");
                } else {
                  loadingDown.classList.add("hidden");
                }
              }
            }
          },
          {
            root: scrollable,
            rootMargin: `${extraRowsToRender * checkboxSize * 2}px`,
          }
        );

        let id = 0;
        for (let y = 1; y <= rowsPerScreen + extraRowsToRender; y++) {
          const div = document.createElement("div");
          div.classList.add("row");
          div.id = `r${y}`;

          for (let x = 1; x <= checkboxesPerRow; x++) {
            const input = document.createElement("input");
            input.type = "checkbox";
            id++;
            input.id = `c${id}`;
            input.title = id;
            div.append(input);
          }

          rowsContainer.append(div);
          rowObserver.observe(div);
        }

        const downObserver = new IntersectionObserver(
          (entries) => {
            if (entries[0].isIntersecting) {
              const lastRow = rowsContainer.lastElementChild;
              const lastRowId = parseInt(lastRow.id.slice(1));
              const lastCheckbox = lastRow.lastElementChild;
              const lastId = parseInt(lastCheckbox.id.slice(1));

              const rowsToRender = Math.min(Math.ceil((totalCheckboxes - lastId) / checkboxesPerRow), extraRowsToRender);

              if (rowsToRender === 0) {
                loadingDown.classList.add("hidden");
                return;
              }

              let id = lastId;
              for (let y = 1; y <= rowsToRender; y++) {
                const div = document.createElement("div");
                div.classList.add("row");
                div.id = `r${y + lastRowId}`;

                const checkboxes = Math.min(totalCheckboxes - id, checkboxesPerRow);

                for (let x = 1; x <= checkboxes; x++) {
                  const input = document.createElement("input");
                  input.type = "checkbox";
                  id++;
                  input.id = `c${id}`;
                  input.title = id;
                  div.append(input);
                }

                rowsContainer.append(div);
                rowObserver.observe(div);
              }
            }
          },
          {
            root: scrollable,
            threshold: 0.5,
          }
        );

        downObserver.observe(loadingDown);

        const upObserver = new IntersectionObserver(
          (entries) => {
            if (entries[0].isIntersecting) {
              const firstRow = rowsContainer.firstElementChild;
              const firstRowId = parseInt(firstRow.id.slice(1));
              const firstCheckbox = firstRow.firstElementChild;
              const firstId = parseInt(firstCheckbox.id.slice(1));

              const rowsToRender = Math.min(firstId / checkboxesPerRow, extraRowsToRender);

              if (rowsToRender === 0) {
                loadingUp.classList.add("hidden");
                return;
              }

              let id = firstId;
              for (let y = 1; y <= rowsToRender; y++) {
                const div = document.createElement("div");
                div.classList.add("row");
                div.id = `r${firstRowId - y}`;

                for (let x = 1; x <= checkboxesPerRow; x++) {
                  const input = document.createElement("input");
                  input.type = "checkbox";
                  id--;
                  input.id = `c${id}`;
                  input.title = id;
                  div.prepend(input);
                }

                rowsContainer.prepend(div);
                rowObserver.observe(div);
              }

              scrollable.scrollTop = extraRowsToRender * checkboxSize;
            }
          },
          {
            root: scrollable,
            threshold: 0.5,
          }
        );

        upObserver.observe(loadingUp);

        const search = document.getElementById("search");

        search.addEventListener("keydown", function (event) {
          if (event.key === "Enter") {
            const idToSearch = this.value;

            if (idToSearch < 1 || idToSearch > totalCheckboxes) {
              return;
            }

            const firstRow = rowsContainer.firstElementChild;
            const firstCheckbox = firstRow.firstElementChild;
            const firstId = parseInt(firstCheckbox.id.slice(1));

            const lastRow = rowsContainer.lastElementChild;
            const lastCheckbox = lastRow.lastElementChild;
            const lastId = parseInt(lastCheckbox.id.slice(1));

            if (idToSearch > lastId || idToSearch < firstId) {
              rowObserver.disconnect();
              upObserver.disconnect();
              downObserver.disconnect();
              loadingUp.classList.add("hidden");
              loadingDown.classList.add("hidden");
              rowsContainer.innerHTML = "";

              const topScreenRowId = Math.min(Math.ceil(idToSearch / checkboxesPerRow), firstRowOfBottomScreen);

              const preExtraRows = Math.min(topScreenRowId - 1, extraRowsToRender);
              const posExtraRows = Math.min(bottomRow - (topScreenRowId - 1) - rowsPerScreen, extraRowsToRender);
              const rowsToRender = preExtraRows + rowsPerScreen + posExtraRows;

              const lastRowId = topScreenRowId - 1 - preExtraRows;
              const lastId = lastRowId * checkboxesPerRow;

              let id = lastId;
              for (let y = 1; y <= rowsToRender; y++) {
                const div = document.createElement("div");
                div.classList.add("row");
                div.id = `r${y + lastRowId}`;

                const checkboxes = Math.min(totalCheckboxes - lastId, checkboxesPerRow);

                for (let x = 1; x <= checkboxes; x++) {
                  const input = document.createElement("input");
                  input.type = "checkbox";
                  id++;
                  input.id = `c${id}`;
                  input.title = id;
                  div.append(input);
                }

                rowsContainer.append(div);
                rowObserver.observe(div);
              }
            }

            const checkbox = document.getElementById(`c${idToSearch}`);

            if (checkbox) {
              checkbox.focus();

              let scrollTimeout;
              function onEvent() {
                clearTimeout(scrollTimeout);

                scrollTimeout = setTimeout(() => {
                  const firstRow = rowsContainer.firstElementChild;
                  const firstCheckbox = firstRow.firstElementChild;
                  const firstId = parseInt(firstCheckbox.id.slice(1));

                  if (firstId > 1) {
                    loadingUp.classList.remove("hidden");
                  }

                  const lastRow = rowsContainer.lastElementChild;
                  const lastCheckbox = lastRow.lastElementChild;
                  const lastId = parseInt(lastCheckbox.id.slice(1));

                  if (lastId < totalCheckboxes) {
                    loadingDown.classList.remove("hidden");
                  }

                  downObserver.observe(loadingDown);
                  upObserver.observe(loadingUp);

                  scrollable.removeEventListener("scroll", onEvent);
                }, 100);
              }
              scrollable.addEventListener("scroll", onEvent);

              const rowToScrollIntoView = document.getElementById(`r${Math.ceil(idToSearch / checkboxesPerRow)}`);
              rowToScrollIntoView.scrollIntoView({ behavior: "smooth", block: "start" });
            }
          }
        });
      }

      main();
    </script>
  </body>
</html>
